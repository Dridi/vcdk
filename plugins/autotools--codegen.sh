# Copyright (C) 2017  Dridi Boukelmoune
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

needs_libtool() {
	test -n "$vmod"
}

###########
# bootstrap
###########

bootstrap() {
m4 -Dneeds_libtool=${vmod:+1} << 'EOF'
include(vcdk.m4)dnl
#!/bin/sh

set -e

WORK_DIR="$PWD"
ROOT_DIR="$(dirname "$0")"

test -n "$ROOT_DIR"
cd "$ROOT_DIR"

ifelse(needs_libtool, [1], [dnl
if ! which libtoolize >/dev/null 2>&1
then
	echo "libtoolize: command not found, falling back to glibtoolize" >&2
	alias libtoolize=glibtoolize
fi

])dnl
mkdir -p m4
aclocal
ifelse(needs_libtool, [1], [dnl
libtoolize --copy --force
])dnl
autoheader
automake --add-missing --copy --foreign
autoconf

cd "$WORK_DIR"
"$ROOT_DIR"/configure "$@"
EOF
}

##############
# configure.ac
##############

configure_ac() {
# TODO: packaging files
m4 -Dneeds_libtool=${vmod:+1} << EOF
include(vcdk.m4)dnl
changequote([{], [}])dnl
AC_PREREQ([2.68])
AC_INIT([$name], [0.1])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_AUX_DIR([build-aux])
AC_CONFIG_HEADER([config.h])

AM_INIT_AUTOMAKE([1.12 -Wall -Werror foreign parallel-tests])
AM_SILENT_RULES([yes])
AM_PROG_AR

ifelse(needs_libtool, {1}, {dnl
LT_PREREQ([2.2.6])
LT_INIT([dlopen disable-static])

})dnl
AC_ARG_WITH([rst2man],
	AS_HELP_STRING(
		[--with-rst2man=PATH],
		[Location of rst2man (auto)]),
	[RST2MAN="\$withval"],
	AC_CHECK_PROGS(RST2MAN, [rst2man rst2man.py], []))

VARNISH_PREREQ([5.2.0])
ifelse({$vmod}, {}, {}, {dnl
VARNISH_VMODS([translit({$vmod}, {,}, { })])
})dnl
ifelse({$vsc}, {}, {}, {dnl
VARNISH_COUNTERS([translit({$vsc}, {,}, { })])
})dnl
ifelse({$vut}, {}, {}, {dnl
VARNISH_UTILITIES([translit({$vut}, {,}, { })])
})dnl

AC_CONFIG_FILES([
	Makefile
	src/Makefile
changequote({[}, {]})dnl
foreachc([], [], [VUT], ([$vut]), [dnl
	src/VUT.rst
])dnl
changequote([{], [}])dnl
])

AC_OUTPUT

AS_ECHO("
	==== \$PACKAGE_STRING ====

	varnish:      \$VARNISH_VERSION
	prefix:       \$prefix
	vmoddir:      \$vmoddir
	vcldir:       \$vcldir
	pkgvcldir:    \$pkgvcldir

	compiler:     \$CC
	cflags:       \$CFLAGS
	ldflags:      \$LDFLAGS
")
EOF
}

#############
# Makefile.am
#############

makefile_am() {
cat << 'EOF'
ACLOCAL_AMFLAGS = -I m4 -I $(VARNISHAPI_DATAROOTDIR)/aclocal

DISTCHECK_CONFIGURE_FLAGS = RST2MAN=:

SUBDIRS = src
EOF
}

#################
# src/Makefile.am
#################

src_makefile_am() {
# TODO: TESTS = tests/vmod_*.vtc tests/vut_*.vtc
# TODO: figure out VSCs
m4 <<EOF
include(vcdk.m4)dnl
AM_CFLAGS = \$(VARNISHAPI_CFLAGS)
ifelse([$vmod], [], [], [dnl

# Modules

vmod_LTLIBRARIES = \\
foreachc([CONT], [ \\], [VMOD], ([$vmod]), [dnl
	libvmod_[]VMOD.la[]CONT
])dnl
foreachc([], [], [VMOD], ([$vmod]), [dnl

libvmod_[]VMOD[]_la_LDFLAGS = \$(VMOD_LDFLAGS)
libvmod_[]VMOD[]_la_SOURCES = vmod_[]VMOD.c
nodist_libvmod_[]VMOD[]_la_SOURCES = \\
	vcc_[]VMOD[]_if.c \\
	vcc_[]VMOD[]_if.h
])dnl

foreachc([], [], [VMOD], ([$vmod]), [dnl
@BUILD_VMOD_[]to_upper(VMOD)@
])dnl
])dnl ifelse vmod
ifelse([$vut], [], [], [dnl

# Utilities

bin_PROGRAMS = \\
foreachc([CONT], [ \\], [VUT], ([$vut]), [dnl
	VUT[]CONT
])dnl
foreachc([], [], [VUT], ([$vut]), [dnl

VUT[]_LDFLAGS = \$(VARNISHAPI_LIBS)
VUT[]_SOURCES = \\
	VUT.c \\
	VUT[]_options.h
])dnl
])dnl ifelse vut

# Test suite

AM_TESTS_ENVIRONMENT = \\
	PATH="\$(abs_builddir):\$(VARNISH_TEST_PATH):\$(PATH)" \\
	LD_LIBRARY_PATH="\$(VARNISH_LIBRARY_PATH)"
TEST_EXTENSIONS = .vtc
VTC_LOG_COMPILER = varnishtest -v
AM_VTC_LOG_FLAGS = \\
	-p vcl_path="\$(abs_top_srcdir)/vcl" \\
	-p vmod_path="\$(abs_builddir)/.libs:\$(vmoddir)"

# Documentation

dist_doc_DATA = \\
foreachc([], [], [VMOD], ([$vmod]), [dnl
	vmod_[]VMOD.vcc \\
])dnl
	\$(TESTS)

dist_man_MANS = \\
foreachc([], [], [VMOD], ([$vmod]), [dnl
	vmod_[]VMOD.3[] \\
])dnl
foreachc([], [], [VUT], ([$vut]), [dnl
	VUT.1 \\
])dnl

foreachc([], [], [VUT], ([$vut]), [dnl
@GENERATE_[]to_upper(VUT)_DOCS@
])dnl

.rst.1:
	\$(AM_V_GEN) \$(RST2MAN) \$< \$@
EOF
}

src_vmod_c() {
cat <<EOF
#include "config.h"

#include <cache/cache.h>
#include <vdef.h>
#include <vrt.h>
#include <vcl.h>

#include "vcc_$1_if.h"

VCL_STRING __match_proto__(td_$1_hello)
vmod_hello(VRT_CTX)
{

	CHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);
	return ("vmod-$1");
}
EOF
}

src_vmod_vcc() {
cat <<EOF
\$Module $1 3 Varnish $1 Module

DESCRIPTION
===========

This VCC file was generated by VCDK, it is used to for both the VMOD
interface and its manual using reStructuredText.

Example
    ::

        import $1;

        sub vcl_deliver {
	    set resp.http.Hello = $1.hello();
        }

\$Function STRING hello()

Description
    Hello world for vmod-$1

SEE ALSO
========

``vcl``\(7),
``varnishd``\(1)
EOF
}

src_vut_c() {
cat <<EOF
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define VOPT_DEFINITION
#define VOPT_INC "$1_options.h"

#include <vapi/voptget.h>
#include <vapi/vsl.h>

#include <vas.h>
#include <vdef.h>
#include <vut.h>

static struct VUT *vut;
static unsigned n_trans = 0;

static void __attribute__((__noreturn__))
usage(int status)
{
	const char **opt;

	fprintf(stderr, "Usage: %s <options>\n\n", vut->progname);
	fprintf(stderr, "Options:\n");
	for (opt = vopt_spec.vopt_usage; *opt != NULL; opt += 2)
		fprintf(stderr, " %-25s %s\n", *opt, *(opt + 1));
	exit(status);
}

static int __match_proto__(VSLQ_dispatch_f)
dispatch(struct VSL_data *vsl, struct VSL_transaction * const *pt, void *priv)
{

	AN(vsl);
	AN(pt);
	AZ(priv);

	/* XXX: process transactions */

	return (0);
}

static void
sighandler(int sig)
{

	if (vut != NULL)
		VUT_Signaled(vut, sig);
}

int
main(int argc, char * const *argv)
{
	int opt;

	vut = VUT_InitProg(argc, argv, &vopt_spec);
	AN(vut);

	/* XXX: parse command line */

	while ((opt = getopt(argc, argv, vopt_spec.vopt_optstring)) != -1) {
		switch (opt) {
		case 'h':
			usage(EXIT_SUCCESS);
			/* no return */
		case 'w':
			/* Write to file */
			INCOMPL();
			break;
		default:
			if (!VUT_Arg(vut, opt, optarg))
				usage(EXIT_FAILURE);
		}
	}

	if (optind != argc)
		usage(EXIT_FAILURE);

	/* XXX: run your utility */

	vut->dispatch_f = dispatch;
	vut->dispatch_priv = NULL;

	VUT_Signal(sighandler);

	VUT_Setup(vut);
	(void)VUT_Main(vut);
	VUT_Fini(&vut);

	return (EXIT_SUCCESS);
}
EOF
}

src_vut_options_h() {
cat << 'EOF'
#include "vapi/vapi_options.h"
#include "vut_options.h"

/* XXX: make your own options */

#define TEMPLATE_OPT_w							\
	VOPT("w:", "[-w <filename>]", "Output filename",		\
	    "Redirect output to file, the file will be overwritten."	\
	)

/* XXX: or take advantage of existing ones, a global option can only be
 *      used by one VUT for the whole process.
 */

VUT_OPT_d
VUT_GLOBAL_OPT_D
VUT_OPT_h
VUT_OPT_k
VSL_OPT_L
VUT_OPT_n
VUT_GLOBAL_OPT_P
VUT_OPT_q
VUT_OPT_r
VUT_OPT_t
TEMPLATE_OPT_w
EOF
}

src_vut_rst_in() {
cat <<EOF
=====
$1
=====

-------------------------
$1 utility for Varnish
-------------------------

:Manual section: 1

SYNOPSIS
========

.. include:: @builddir@/$1_synopsis.rst
$1 |synopsis|

DESCRIPTION
===========

This RST file was generated by VCDK, it is processed by autoconf to easily
solve the lack of include path in reStructuredText. This ensures that the
documentation generated by the VUT is always included from the build
directory.

The following options are available:

.. include:: @builddir@/$1_options.rst

SIGNALS
=======

SIGUSR1
    Flush any outstanding transactions

SEE ALSO
========

``vcl``\(7),
``varnishd``\(1)

EOF
}
